# Modern Development Setup

A list of steps to ensure that a library or an npm package is setup with modern web development best practices.

<h2 class="header"> A Modern Development Setup Includes </h2>

- Version control
  - Git - https://git-scm.com/
- Automated CI/CD pipeline
  - Releases / deployment will be completely automated
- Code Quality w/ Tooling - to maintain solid principles/standard for writing quality code
  - ESLint
  - Prettier
- Module Support - to ensure that code can be executed on a browser and/or server side
  - CommonJS
  - ES Modules
  - UMD
- Documentation
- Demo + Example

<h2 class="header"> Build Process Cycle </h2>

- An automated sequence of tasks ran on push, tag and/or release
- Steps:
  - installation, i.e., `npm install`
    - clean install - `npm ci`
    - security audit - `npm audit`
  - lint
    - linter - eslint / stylelint
    - format code w/ prettier
  - test
    - npm test (w/ mocha or jest)
    - code coverage (nyc, codecov, coveralls)
  - build
    - transpile - Babel / TypeScript
    - pre-process - compilation + auto-prefix - Sass, Less, PostCSS
    - Uglify (minify + optimize) - uglify.js, terser
    - bundle (concat, tree shake) - webpack, rollup, browserify
    - compress (gzip)
    - extras - check bundle size, strip unused code (ts/flow/proptypes)
  - push
    - release to github
    - publish to NPM
  - deploy
    - deploy to host (heroku, surge, github pages)

<h2 class="header"> Instructions </h2>

### Setup Package Manager w/ NPM

- on the root level, run `npm init` and setup a package.json file
- example:

```json
{
  "name": "nsp-math",
  "version": "0.0.1",
  "description": "A simple math library to demonstrate a modern setup of a library or an NPM package",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/npranto/math.js.git"
  },
  "keywords": ["math.js", "modern-web-dev", "setup", "library", "package"],
  "author": "Nazmuz Pranto <npranto@gmail.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/npranto/math.js/issues"
  },
  "homepage": "https://github.com/npranto/math.js#readme"
}
```

### Setup .editorconfig

- a set of rules for code editors to follow standard, consistent coding style
- on the root level, create a new file `.editorconfig` and setup a list of editorconfig properties in it
- for a complete list of EditorConfig Properties, refer to https://github.com/editorconfig/editorconfig/wiki/EditorConfig-Properties
- for VSCode to abide by the editorconfig rules, install the `EditorConfig for VS Code` extension
- resources:
  - https://www.youtube.com/watch?v=YbHw1VdjWbA&t=2s
  - https://www.youtube.com/watch?v=5eOCn7KTac4
  - https://www.youtube.com/watch?v=NyhIcUbyj6U
- example:

```
root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
indent_style = space
indent_size = 2
trim_trailing_whitespace: true
insert_final_newline: true
```

### Setup .gitignore

- to ignore files and/or directories that we want to exclude from being committed to git
- create a new file `.gitignore` and add a list of files or directories to exclude
- example:

```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.pnp.*
```

### Setup ESLint w/ Prettier Integration

- Setup ESLint:
  - install `eslint` package - `npm install -D eslint`
  - setup ESLint on the root level by running `npx eslint --init`, which should configure a .eslintrc.json file automatically
  - go into package.json file and add a script to lint all your source code like this:
  ```json
  "script": {
    "lint": "npx eslint ./"
  }
  ```
  - now, just run `npm run lint` to list any recommended ESLint errors or warning to fix based on chosen ESLint rule set.
- To Fix ESLint Issues:
  - setup another npm script and pass in a `--fix` option to `eslint` CLI like this:
  ```json
  "script": {
    "lint:fix": "npx eslint ./ --fix"
  }
  ```
  - now, running `npm run lint:fix` should attempt to fix most, if not all ESLint issues identified automatically
- Format Code w/ Prettier:
  - While ESLint spells out the actual rule sets for standard code, prettier deals with formatting the actual code and making it look "pretty" and readable for everyone.
  - first, install prettier-eslint package - `npm install -D prettier-eslint`
  - then, install the CLI for prettier eslint - `npm install -D prettier-eslint-cli`
  - now, add another script to actually format all the source code like this:
  ```json
  "script": {
    "format": "npx prettier-eslint \"$PWD/src/**/*.js\" --write"
  }
  ```
- Format Code On Save (for VSCode only):
  - install `Prettier - Code Formatter` extension for VSCode
  - create a `.vscode` directory on the root level and create a file called `settings.json`
  - inside it add the following configuration:
  ```json
  {
    "editor.formatOnSave": true,
    "prettier.eslintIntegration": true // formats based on set eslint rules
  }
  ```
  - now, prettier should automatically format your code when you saves
- Add .eslintignore + .prettierignore files
  - to disable certain files or directories from being included in linting or formating process
  - apply it "dist" or "build" directories mostly
  - example:
  ```
  dist
  node_modules
  ```

### Setup "Husky" for Git Hooks

- perform certain task(s) on git commit or push, like `npm test` or `npm run lint`
- install husky - `npm install -D husky`
- configure a `.huskyrc.json` file to use git precommit and prepush hooks

```
{
  "hooks": {
    "pre-commit": "npm run lint"
  }
}
```

### Add Rollup Bundler

- a robust setup instruction - https://risanb.com/code/bundling-your-javascript-library-with-rollup/

### Setup peerDependencies
- since we do not want third party packages that our library is using to be included as part our library production builds (to reduce build size), we need to setup peer dependencies for them. In that case, consumers of our library would have to install them seprately.
- setup peerDependencies inside package.json file like this:
```
"peerDependencies": {
  "lodash": "4.17.15"
}
```

### Specify "engine" for Library
- setup engines inside package.json file like this:
```
"engines": {
  "node": ">=8" // usually the same as babel config target env. for node
}
```

### Add Examples
- add examples of library being used properly with CommonJS, ES Module and in UMD format.
- CommonJS
  - add an `examples` directory to the root level
  - create a directory inside it and name is `cjs`
  - inside `cjs` directory:
    - initialize npm - `npm init -y`
    - install the library with npm by reference 2 levels up in the directory hierarchy like this:
    ```
    npm install ../..
    ```
    - now, you should have the library you want to test inside the package.json file within `cjs` directory
    - now just create a simple `index.js` file in the `cjs` directory and test if the libraries functionalities work as expected.
    ```
    const myLibrary = require('my-library');
    console.log(myLibrary); // checking if library functioalities are available
    ```
- UMD
  - add an `examples` directory to the root level
  - create a directory inside it and name is `umd`
  - inside `umd` directory:
    - initialize npm - `npm init -y`
    - install the library with npm by reference 2 levels up in the directory hierarchy like this:
    ```
    npm install ../..
    ```
    - now, you should have the library you want to test inside the package.json file within `umd` directory
    - create an `index.html` file
    - add the basic level of HTML needed to render it on a browser, like this:
    ```
    <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Document</title>
        </head>
        <body>
        </body>
      </html>
    ```
    - add scripts to CDNs for any dependncies of the library, i.e., react, lodash, moment.js , like this:
    ```
    <body>
      ...
      <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js"
        integrity="sha256-VeNaFBVDhoX3H+gJ37DpT/nTuZTdjYro9yBruHjVmoQ=" crossorigin="anonymous"></script>
      ...
    </body>
    ```
    - now add a script referencing the library you want to test from node_modules, like this:
    ```
    <body>
      ...
      <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js"
        integrity="sha256-VeNaFBVDhoX3H+gJ37DpT/nTuZTdjYro9yBruHjVmoQ=" crossorigin="anonymous"></script>
      ...
      <script src="./node_modules/myLibrary/build/index.umd.js"></script>
      ...
    ```
    - now, add another script tag underneath both dependencies and library scripts and test the usage of library, like this:
    ```
    <script>
      const { add, subtract, multiply, divide } = window.myLibrary;
      const addExample = add(1, 2, 3);
      const subtractExample = subtract(10, 5);
      const multiplyExample = multiply(1, 2, 3);
      const divideExample = divide(10, 5);

      // eslint-disable-next-line no-console
      console.log({
        addExample,
        subtractExample,
        multiplyExample,
        divideExample,
      });
    </script>
    ```
- es
  - To test ES Modules, it's best to install the library you want to test inside that project that utilizes webpack or rollup to bundle a project. Thus, as an example, just create a example `create-react-app` and test inside it
  - create a directory inside it and name is `es`
  - inside `es` directory:
    - initialize npm - `npm init -y`
    - install the library with npm by reference 2 levels up in the directory hierarchy like this:
    ```
    npm install ../..
    ```
    - now, you should have the library you want to test inside the package.json file within `es` directory
    - import in the library inside a component and check to see if the functinalities are working as expected, like this
    ```
    import React from 'react';
    import { add, subtract, multiply, divide } from 'myLibrary';

    function App() {
      const addExample = add(1, 2, 3);
      const subtractExample = subtract(10, 5);
      const multiplyExample = multiply(1, 2, 3);
      const divideExample = divide(10, 5);

      // eslint-disable-next-line no-console
      console.log({
        addExample,
        subtractExample,
        multiplyExample,
        divideExample,
      });

      return null;
    }

    export default App;
    ```
### Add Unit Test:
- install mocha - `npm install -D mocha`
- install chai testing utility library -  `npm install -D chai`
- add a `test` directory on the root level
- add unit test files within it w/ `*.spec.js` or `*.test.js` extention
- install babel specific packages in order to run ES6 code within unit test:
  - @babel/core - `npm i -D @babel/core`
  - @babel/preset-env - `npm i -D @babel/preset-env`
  - @babel/register - `npm i -D @babel/register`
- add preset within `.babelrc` file in the root
```
{
  "presets": [
    "@babel/preset-env"
  ]
}
```
- add an npm script to run tests:
```
"scripts": {
  "test": "npx mocha --require @babel/register \"test/**/*.js\""
},
```

<h2 class="header">Questions</h2>

- Why git and not any other version control?
- Are there any close alternatives to git?
- What is CI/CD pipeline?
- Why do I need to setup automated releases and deployments or CI/CD for a project?
- What other tools can I use to ensure better code quality, in addition to eslint and prettier?
- Can I use CommonJS module on the browser? What about support for Node core modules (i.e., child_process, net). How can I ensure that browser can use that as well?
- Find a tutorial for editorconfig and how to set it up on VSCode and Atom
- look into creative UIs for running pre-commit hooks (like w/ loading spinners and so on)
- read more on babel presets and babel parser in general
- TODO: only minify builds on production

<style>
  .header {
    font-weight: bold;
    border-bottom: 3px solid orange;
  }
  .center {
    text-align: center;
  }
</style>
